// Copyright 2025, Colin McKee
// SPDX-License-Identifier: Apache-2.0
package io.github.fletchmckee.ktjni.internal

import com.google.common.truth.Truth
import java.io.File
import java.io.FileOutputStream
import java.io.PrintWriter
import java.io.StringWriter
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.io.TempDir
import org.objectweb.asm.ClassWriter
import org.objectweb.asm.Opcodes
import org.objectweb.asm.tree.ClassNode
import org.objectweb.asm.tree.FieldNode
import org.objectweb.asm.tree.MethodNode

class KtjniWriterTest {
  @TempDir
  lateinit var tempDir: File

  @Test
  fun `writePrologue - generates correct header format`() {
    val stringWriter = StringWriter()
    PrintWriter(stringWriter).use { out ->
      out.writePrologue("com_example_Example")
    }

    val result = stringWriter.toString()
    Truth.assertThat(result).isEqualTo(
      """
      /* DO NOT EDIT THIS FILE - it is machine generated */
      #include <jni.h>
      /* Header for class com_example_Example */

      #ifndef _Included_com_example_Example
      #define _Included_com_example_Example
      #ifdef __cplusplus
      extern "C" {
      #endif


      """.trimIndent(),
    ) // There are 2 lines at the end as it preps a new line to be consumed by the epilogue.
  }

  @Test
  fun `writeEpilogue - generates correct footer format`() {
    val stringWriter = StringWriter()
    PrintWriter(stringWriter).use { out ->
      out.writeEpilogue()
    }

    val result = stringWriter.toString()
    Truth.assertThat(result).isEqualTo(
      """
      #ifdef __cplusplus
      }
      #endif
      #endif

      """.trimIndent(),
    )
  }

  @Test
  fun `writeNativeMethods - handles non-overloaded methods correctly`() {
    val nativeMethods = listOf(
      fakeMethodNode("nativeMethod1", "()V"),
      fakeMethodNode("nativeMethod2", "(ILjava/lang/String;)Z"),
    )

    val overloadedMethodMap = mapOf("nativeMethod1" to 1, "nativeMethod2" to 1)

    val stringWriter = StringWriter()
    PrintWriter(stringWriter).use { out ->
      out.writeNativeMethods(
        "com_example_Example",
        "com.example.Example",
        nativeMethods,
        overloadedMethodMap,
      )
    }

    val output = stringWriter.toString()

    Truth.assertThat(output).isEqualTo(
      """
      /*
       * Class:     com_example_Example
       * Method:    nativeMethod1
       * Signature: ()V
       */
      JNIEXPORT void JNICALL Java_com_example_Example_nativeMethod1
        (JNIEnv *, jobject);

      /*
       * Class:     com_example_Example
       * Method:    nativeMethod2
       * Signature: (ILjava/lang/String;)Z
       */
      JNIEXPORT jboolean JNICALL Java_com_example_Example_nativeMethod2
        (JNIEnv *, jobject, jint, jstring);


      """.trimIndent(),
    ) // There are 2 lines at the end as it preps a new line to be consumed by the epilogue.
  }

  @Test
  fun `writeNativeMethods - handles overloaded methods correctly`() {
    val nativeMethods = listOf(
      fakeMethodNode("overloadedMethod", "()V"),
      fakeMethodNode("overloadedMethod", "(I)V"),
    )

    val overloadedMethodMap = mapOf("overloadedMethod" to 2)

    val stringWriter = StringWriter()
    PrintWriter(stringWriter).use { out ->
      out.writeNativeMethods(
        "com_example_Example",
        "com.example.Example",
        nativeMethods,
        overloadedMethodMap,
      )
    }

    val result = stringWriter.toString()

    Truth.assertThat(result).isEqualTo(
      """
      /*
       * Class:     com_example_Example
       * Method:    overloadedMethod
       * Signature: ()V
       */
      JNIEXPORT void JNICALL Java_com_example_Example_overloadedMethod__
        (JNIEnv *, jobject);

      /*
       * Class:     com_example_Example
       * Method:    overloadedMethod
       * Signature: (I)V
       */
      JNIEXPORT void JNICALL Java_com_example_Example_overloadedMethod__I
        (JNIEnv *, jobject, jint);


      """.trimIndent(),
    ) // There are 2 lines at the end as it preps a new line to be consumed by the epilogue.
  }

  @Test
  fun `writeStatics - generates correct constant definitions`() {
    val classNode = ClassNode()
    classNode.name = "com/example/Example"
    classNode.access = Opcodes.ACC_PUBLIC
    classNode.superName = "java/lang/Object"
    classNode.version = Opcodes.V1_8
    classNode.fields = listOf(
      FieldNode(
        (Opcodes.ACC_STATIC or Opcodes.ACC_FINAL),
        "INT_CONSTANT", // name
        "I", // descriptor
        null, // signature
        42, // value
      ),
      FieldNode(
        (Opcodes.ACC_STATIC or Opcodes.ACC_FINAL),
        "STRING_CONSTANT", // name
        "Ljava/lang/String;", // descriptor
        null, // signature
        "test", // value
      ),
    )

    // Write the class to a file so buildClassHierarchy can find it.
    writeTemporaryClassFile(classNode)

    val stringWriter = StringWriter()
    PrintWriter(stringWriter).use { out ->
      out.writeStatics(
        classNode = classNode,
        cName = "com_example_Example",
        srcDir = tempDir,
      )
    }

    val result = stringWriter.toString()
    Truth.assertThat(result).isEqualTo(
      """
      #undef com_example_Example_INT_CONSTANT
      #define com_example_Example_INT_CONSTANT 42L

      #undef com_example_Example_STRING_CONSTANT
      #define com_example_Example_STRING_CONSTANT "test"


      """.trimIndent(),
    ) // There are 2 lines at the end as it preps a new line to be consumed by the epilogue.
  }

  @Test
  fun `toMangledJniName - handles special characters correctly`() {
    Truth.assertThat("java.lang.String".toMangledJniName()).isEqualTo("java_lang_String")
    Truth.assertThat("com.example.Class\$Inner".toMangledJniName()).isEqualTo("com_example_Class__Inner")
    Truth.assertThat("com.example.Class+".toMangledJniName()).isEqualTo("com_example_Class_0002b")
    Truth.assertThat("com_example_Class".toMangledJniName()).isEqualTo("com_example_Class")
    Truth.assertThat("com\$example\$Class".toMangledJniName()).isEqualTo("com__example__Class")
    Truth.assertThat("weird@class#name".toMangledJniName()).isEqualTo("weird_00040class_00023name")
  }

  @Test
  fun `toJniIdentifier - encodes method names correctly`() {
    // Basic cases
    Truth.assertThat("getName".toJniIdentifier()).isEqualTo("getName")
    Truth.assertThat("com/example/method".toJniIdentifier()).isEqualTo("com_example_method")

    // Special character handling
    Truth.assertThat("process_data".toJniIdentifier()).isEqualTo("process_1data")
    Truth.assertThat("handle;input".toJniIdentifier()).isEqualTo("handle_2input")
    Truth.assertThat("process[array]".toJniIdentifier()).isEqualTo("process_3array_0005d")
    Truth.assertThat("weird@method".toJniIdentifier()).isEqualTo("weird_00040method")
  }

  @Test
  fun `toJniFieldStub - preserves alphanumeric and underscores`() {
    Truth.assertThat("CONSTANT_VALUE".toJniFieldStub()).isEqualTo("CONSTANT_VALUE")
    Truth.assertThat("has_multiple_underscores".toJniFieldStub()).isEqualTo("has_multiple_underscores")
    Truth.assertThat("special@char#field".toJniFieldStub()).isEqualTo("special_00040char_00023field")
    Truth.assertThat("123numeric".toJniFieldStub()).isEqualTo("123numeric")
  }

  @Test
  fun `toJniSymbol - converts characters to hex representation`() {
    Truth.assertThat('@'.toJniSymbol()).isEqualTo("_00040")
    Truth.assertThat('#'.toJniSymbol()).isEqualTo("_00023")
    Truth.assertThat('+'.toJniSymbol()).isEqualTo("_0002b")
    Truth.assertThat('Î»'.toJniSymbol()).isEqualTo("_003bb")
  }

  @Test
  fun `toMangledJniMethod - non-overloaded method with no arguments`() {
    val methodNode = fakeMethodNode("nativeMethod", "()V")
    Truth.assertThat(methodNode.toMangledJniMethod("com.example.TestClass", false))
      .isEqualTo("Java_com_example_TestClass_nativeMethod")
  }

  @Test
  fun `toMangledJniMethod - overloaded method with no arguments`() {
    val methodNode = fakeMethodNode("nativeMethod", "()V")
    Truth.assertThat(methodNode.toMangledJniMethod("com.example.TestClass", true))
      .isEqualTo("Java_com_example_TestClass_nativeMethod__")
  }

  @Test
  fun `toMangledJniMethod - overloaded method with primitive arguments`() {
    val methodNode = fakeMethodNode("nativeMethod", "(I)V")
    Truth.assertThat(methodNode.toMangledJniMethod("com.example.TestClass", true))
      .isEqualTo("Java_com_example_TestClass_nativeMethod__I")
  }

  @Test
  fun `toMangledJniMethod - overloaded method with object argument`() {
    val methodNode = fakeMethodNode("nativeMethod", "(Ljava/lang/String;)V")
    Truth.assertThat(methodNode.toMangledJniMethod("com.example.TestClass", true))
      .isEqualTo("Java_com_example_TestClass_nativeMethod__Ljava_lang_String_2")
  }

  @Test
  fun `test overloaded method with array arguments`() {
    val methodNode = fakeMethodNode("nativeMethod", "([I[F)V")
    Truth.assertThat(methodNode.toMangledJniMethod("com.example.TestClass", true))
      .isEqualTo("Java_com_example_TestClass_nativeMethod___3I_3F")
  }

  @Test
  fun `test overloaded method with multidimensional arrays`() {
    val methodNode = fakeMethodNode("nativeMethod", "([[I[[[F)V")
    Truth.assertThat(methodNode.toMangledJniMethod("com.example.TestClass", true))
      .isEqualTo("Java_com_example_TestClass_nativeMethod___3_3I_3_3_3F")
  }

  @Test
  fun `test overloaded method with object arrays`() {
    val methodNode = fakeMethodNode("nativeMethod", "([Ljava/lang/String;)V")
    Truth.assertThat(methodNode.toMangledJniMethod("com.example.TestClass", true))
      .isEqualTo("Java_com_example_TestClass_nativeMethod___3Ljava_lang_String_2")
  }

  @Test
  fun `toMangledJniMethod - overloaded method with special characters`() {
    val methodNode = fakeMethodNode("process_data", "(Ljava/lang/String;)Z")
    Truth.assertThat(methodNode.toMangledJniMethod("com.example.TestClass", true))
      .isEqualTo("Java_com_example_TestClass_process_1data__Ljava_lang_String_2")
  }

  @Test
  fun `toMangledJniName - complex mixed argument types`() {
    val methodNode = fakeMethodNode("nativeMethod", "(I[FJLjava/lang/String;[[Z)V")
    Truth.assertThat(methodNode.toMangledJniMethod("com.example.TestClass", true))
      .isEqualTo("Java_com_example_TestClass_nativeMethod__I_3FJLjava_lang_String_2_3_3Z")
  }

  private fun fakeMethodNode(name: String, descriptor: String): MethodNode = MethodNode().apply {
    this.name = name
    this.desc = descriptor
  }

  private fun writeTemporaryClassFile(classNode: ClassNode) {
    val classFile = File(tempDir, "${classNode.name.replace('/', File.separatorChar)}.class")
    classFile.parentFile.mkdirs()
    FileOutputStream(classFile).use { out ->
      val classWriter = ClassWriter(ClassWriter.COMPUTE_FRAMES)
      classNode.accept(classWriter)
      out.write(classWriter.toByteArray())
    }
  }
}
